https://rheina-adinda-strikeapparel.pbp.cs.ui.ac.id/

TUGAS 6

Apa perbedaan antara synchronous request dan asynchronous request? Perbedaan fundamental antara synchronous request dan asynchronous request terletak pada bagaimana browser menangani alur komunikasi dengan server. Dalam model synchronous, browser mengirimkan sebuah permintaan ke server dan kemudian berhenti total atau "terblokir". Akibatnya, pengguna tidak bisa melakukan interaksi apa pun dengan halaman web, seperti mengklik tombol atau bahkan melakukan scroll, sampai server selesai memproses dan mengirimkan kembali respons penuh. Ini adalah perilaku klasik dari sebuah full page reload. Sebaliknya, dalam model asynchronous yang digunakan oleh AJAX, browser mengirimkan permintaan di latar belakang melalui JavaScript. Artinya, pengguna tetap bisa berinteraksi dengan halaman secara normal selagi permintaan tersebut diproses. Ketika server mengirimkan kembali respons (biasanya dalam format data ringkas seperti JSON), sebuah fungsi JavaScript akan dieksekusi untuk memperbarui hanya bagian tertentu dari halaman tanpa perlu me-reload seluruhnya.

Bagaimana AJAX bekerja di Django (alur request-response)? Alur kerja AJAX di dalam ekosistem Django melibatkan koordinasi antara sisi klien (JavaScript) dan sisi server (Django). Prosesnya diawali di sisi klien ketika sebuah event terjadi, misalnya pengguna mengklik tombol hapus produk. JavaScript kemudian akan "mencegat" aksi ini, mencegah perilaku bawaan browser, dan mengirimkan sebuah permintaan HTTP (umumnya menggunakan fetch API) ke sebuah URL endpoint spesifik yang telah kita definisikan. Untuk permintaan yang mengubah data seperti POST, misalnya saat menambah atau mengedit produk, permintaan ini wajib menyertakan CSRF Token di dalam header untuk alasan keamanan. Di sisi server, urls.py akan memetakan URL tersebut ke sebuah fungsi view di dalam views.py. Berbeda dengan view biasa yang me-render template HTML, view AJAX ini akan menjalankan logika bisnis, seperti menyimpan data ke database atau memvalidasi form, dan kemudian mengembalikan respons dalam format data, bukan HTML. Di Django, ini biasanya dilakukan dengan JsonResponse. Setelah data JSON diterima kembali oleh klien, JavaScript akan mengeksekusinya untuk melakukan manipulasi DOM, seperti menampilkan notifikasi toast, menambahkan elemen baru ke dalam daftar produk, atau memperbarui tampilan tanpa perlu satu pun full page reload.

Apa keuntungan menggunakan AJAX dibandingkan render biasa di Django? Keuntungan utama menggunakan AJAX dibandingkan dengan metode render biasa di Django berpusat pada peningkatan drastis dari segi user experience dan efisiensi. Pertama, interaktivitas aplikasi terasa jauh lebih cepat dan mulus. Karena tidak ada full page reload, pengguna tidak akan melihat layar putih berkedip setiap kali melakukan aksi. Aksi seperti memfilter produk atau menyimpan perubahan terasa instan, memberikan kesan seperti menggunakan aplikasi desktop yang responsif. Kedua, terjadi efisiensi transfer data. AJAX hanya meminta dan menerima data yang benar-benar dibutuhkan, biasanya dalam format JSON yang sangat ringan. Ini sangat kontras dengan render biasa yang mengharuskan server mengirim ulang seluruh dokumen HTML, termasuk navbar, sidebar, dan footer yang tidak berubah. Pengurangan ukuran data ini sangat signifikan, terutama bagi pengguna dengan koneksi internet yang lambat atau terbatas. Ketiga, beban server berkurang. Karena Django tidak perlu lagi menjalankan proses rendering template yang kompleks untuk setiap interaksi kecil, server dapat menangani lebih banyak permintaan dengan sumber daya yang lebih sedikit, karena tugasnya hanya memproses logika dan mengirimkan data.

Bagaimana cara memastikan keamanan saat menggunakan AJAX untuk fitur Login dan Register di Django? Meskipun transport datanya berbeda, prinsip keamanan saat menggunakan AJAX untuk fitur Login dan Register di Django tetap sama dengan metode tradisional, dan Django sudah menyediakan mekanisme yang kuat untuk ini. Langkah paling krusial adalah memastikan proteksi CSRF (Cross-Site Request Forgery) tetap aktif. Untuk setiap permintaan POST yang dikirim via JavaScript, kita wajib mengambil CSRF Token yang disediakan Django (baik dari cookie maupun elemen form) dan menyertakannya di dalam header permintaan sebagai X-CSRFToken. Tanpa ini, Django akan menolak permintaan tersebut. Kedua, seluruh proses autentikasi harus selalu dilakukan di sisi server menggunakan framework bawaan Django yang sudah teruji keamanannya, seperti fungsi authenticate() dan login(). AJAX di sisi klien hanya bertugas mengirimkan kredensial; proses validasi, pengecekan password hash, dan pembuatan sesi tetap menjadi tanggung jawab penuh backend. Ketiga, validasi form (menggunakan AuthenticationForm atau form kustom) harus tetap dijalankan di view untuk menangani input yang tidak valid sebelum diproses lebih lanjut. Terakhir, dan yang paling fundamental, seluruh komunikasi yang berisi data sensitif seperti password harus selalu dienkripsi menggunakan HTTPS di lingkungan produksi untuk mencegah penyadapan data.

Bagaimana AJAX mempengaruhi pengalaman pengguna (User Experience) pada website? AJAX secara fundamental mengubah website dari kumpulan halaman statis menjadi sebuah aplikasi yang dinamis dan interaktif, yang secara langsung meningkatkan pengalaman pengguna (User Experience) dalam beberapa aspek kunci. Pertama, kecepatan yang dirasakan pengguna meningkat secara dramatis. Aksi-aksi yang sebelumnya membutuhkan penungguan untuk reload halaman penuh, seperti memfilter daftar produk atau mengirim komentar, kini terasa instan karena hanya bagian relevan dari halaman yang diperbarui. Kedua, AJAX memungkinkan umpan balik (feedback) yang lebih kaya dan kontekstual. Contohnya adalah kemunculan loading spinner saat data sedang diambil, atau notifikasi toast "sukses" atau "gagal" yang muncul tanpa mengganggu alur kerja pengguna. Ini membuat pengguna selalu tahu apa yang sedang terjadi. Ketiga, konteks pengguna tidak hilang. Karena halaman tidak di-reload, pengguna tidak akan kehilangan posisi scroll mereka, teks yang sudah mereka ketik di kolom lain, atau keadaan komponen interaktif lainnya. Dalam konteks app ini, pengguna dapat mengedit produk melalui modal, menyimpannya, dan langsung melihat perubahan pada daftar produk tanpa harus mencari ulang produk yang baru saja ia edit. Secara keseluruhan, AJAX membuat website terasa lebih mulus, profesional, dan lebih menghargai waktu pengguna.

TUGAS 5

Jika terdapat beberapa CSS selector untuk suatu elemen HTML, jelaskan urutan prioritas pengambilan CSS selector tersebut! Kalau ada lebih dari satu CSS selector yang mengatur sebuah elemen, browser akan memilih gaya mana yang dipakai dengan urutan prioritas tertentu. Aturan yang diberi !important selalu menjadi yang teratas. Kalau tidak ada !important, maka aturan dengan spesifisitas lebih tinggi akan dipilih—misalnya inline style lebih kuat daripada ID, ID lebih kuat daripada class, dan class lebih kuat daripada selector elemen. Jika tingkat spesifisitasnya sama, aturan yang ditulis paling akhir di dalam CSS atau urutan stylesheet akan berlaku. Kalau tidak ada aturan khusus, elemen dapat menggunakan properti yang diwariskan dari elemen induknya. Singkatnya: !important → spesifisitas → urutan penulisan → inheritance.

Mengapa responsive design menjadi konsep yang penting dalam pengembangan aplikasi web? Berikan contoh aplikasi yang sudah dan belum menerapkan responsive design, serta jelaskan mengapa! Desain responsif sangat penting dalam pengembangan aplikasi web karena memungkinkan tampilan menyesuaikan diri secara otomatis dengan berbagai ukuran layar, mulai dari desktop hingga perangkat mobile. Dengan begitu, pengguna dapat mengakses informasi dengan nyaman tanpa perlu sering melakukan zoom in atau scroll berlebihan, sehingga pengalaman yang didapat tetap konsisten dan menyenangkan. Contohnya, platform e-commerce seperti Tokopedia atau Shopee sudah menerapkan desain responsif dengan baik: tampilan produk tetap teratur dan navigasi tetap mudah meski dibuka lewat layar ponsel. Sebaliknya, masih ada beberapa situs lama milik instansi pemerintah yang belum menggunakan desain responsif, sehingga saat diakses lewat smartphone, teks dan menu terlihat berantakan serta sulit digunakan. Hal ini menunjukkan bahwa desain responsif tidak hanya meningkatkan kenyamanan pengguna, tetapi juga mendukung aksesibilitas dan efektivitas aplikasi web di berbagai perangkat.

Jelaskan perbedaan antara margin, border, dan padding, serta cara untuk mengimplementasikan ketiga hal tersebut! Margin, border, dan padding merupakan bagian penting dari CSS box model yang mengatur ruang di sekitar elemen. Margin berfungsi sebagai jarak luar, yaitu ruang antara suatu elemen dengan elemen lain di sekitarnya. Border adalah garis pembatas yang mengelilingi elemen dan terletak di antara margin serta padding. Sementara itu, padding adalah jarak di dalam elemen, tepatnya ruang antara konten (seperti teks atau gambar) dengan border. Contoh penerapannya: margin: 20px memberikan jarak luar 20 piksel, border: 2px solid black menambahkan garis hitam tebal 2 piksel di sekeliling elemen, dan padding: 10px memberi ruang di dalam elemen agar konten tidak menempel langsung pada border. Dengan memahami perbedaan ini, developer dapat mengatur layout halaman web agar lebih terstruktur, rapi, dan mudah dipahami.

Jelaskan konsep flex box dan grid layout beserta kegunaannya! Flexbox dan Grid Layout adalah dua metode tata letak modern di CSS yang memudahkan pengaturan posisi elemen secara fleksibel dan efisien. Flexbox berfokus pada tata letak satu dimensi, baik secara horizontal (row) maupun vertikal (column), sehingga sangat ideal untuk menyusun elemen berurutan seperti navbar, daftar card, atau form yang responsif. Sebaliknya, Grid Layout bekerja pada dua dimensi sekaligus, yaitu baris dan kolom, sehingga lebih cocok digunakan untuk membangun struktur halaman yang kompleks, misalnya layout dashboard, majalah online, atau template website dengan banyak bagian. Kedua sistem ini membantu developer menciptakan desain responsif dengan lebih mudah karena elemen dapat menyesuaikan berbagai ukuran layar tanpa perlu banyak kode tambahan, sekaligus menjaga tampilan web tetap konsisten dan terorganisir di berbagai perangkat.

Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step (bukan hanya sekadar mengikuti tutorial)! Untuk mengimplementasikan fungsi untuk menghapus dan mengedit product adalah pertama menambahkan fungsi edit_product dan delete_product nya ke views.py. Lalu, membuat file baru dengan nama edit_product.html dan mengisi code nya. Setelah itu, menambahkan import fungsi-fungsi yg telah dibuat pada urls.py yg ada pada direktori main dan menambahkan path url tersebut ke urlpatterns nya. Terakhir, menambah code pada main.html yaitu loop pada product_list agar memunculkan tombot edit dan juga delete pada setiap card product.

Kemudian, saya menghias semua html sesuai collor palette saya, yaitu orange. Selain itu, saya juga menambahkan fitur-fitur responsif pada html saya seperti di card product yang bisa timbul ketika di hover. Jika produk belum ada, saya tampilkan no image placeholder untuk menunjukkan produk tidak ada. Saya juga menambahkan tombol edit dan delete product. Saya juga mengubah navbar agar lebih menarik serta menambahkan filter category di main.

TUGAS 4
Apa itu Django AuthenticationForm? Jelaskan juga kelebihan dan kekurangannya.
-> Django AuthenticationForm adalah form bawaan dari django.contrib.auth.forms yang digunakan untuk menangani proses login pengguna dengan field username dan password, otomatis memvalidasi kredensial terhadap model User, dan mengembalikan instance User jika berhasil.Kelebihannya, siap pakai, otomatis validasi, dan terintegrasi dengan model User, sedangkan kekurangannya kurang fleksibel untuk menambahkan field custom dan tampilan default minimal.

Apa perbedaan antara autentikasi dan otorisasi? Bagaiamana Django mengimplementasikan kedua konsep tersebut?
-> Autentikasi adalah proses verifikasi identitas pengguna (siapa kamu?), sedangkan otorisasi adalah penentuan akses dan hak setelah verifikasi (apa yang boleh kamu lakukan?). Di Django, autentikasi diimplementasikan melalui django.contrib.auth dengan fungsi seperti authenticate(), login(), dan form seperti AuthenticationForm, otorisasi menggunakan sistem permission dan group pada model User, dengan decorator @login_required atau @permission_required untuk membatasi view, serta method user.has_perm() untuk pengecekan akses berdasarkan role atau permission spesifik. 

Apa saja kelebihan dan kekurangan session dan cookies dalam konteks menyimpan state di aplikasi web?
-> Session menyimpan data di server-side dengan ID disimpan di client cookie, menawarkan kelebihan keamanan tinggi (data sensitif tidak terpapar) dan kapasitas tak terbatas, tapi kekurangannya adalah beban server yang tinggi dan ketergantungan pada koneksi persisten; sedangkan cookies menyimpan data langsung di client-side, unggul dalam performa cepat dan akses offline, namun rentan terhadap pencurian (seperti XSS/CSRF) dan dibatasi ukuran 4KB, membuatnya kurang aman untuk data rahasia tanpa enkripsi. XSS/CSRF: Serangan di mana hacker menyisipkan kode jahat di browser untuk curi data atau palsukan aksi pengguna.

Apakah penggunaan cookies aman secara default dalam pengembangan web, atau apakah ada risiko potensial yang harus 
diwaspadai? Bagaimana Django menangani hal tersebut?
-> Penggunaan cookies tidak aman secara default karena rentan terhadap serangan seperti session hijacking (pencurian ID sesi), CSRF (pemalsuan permintaan), dan pencurian via XSS, terutama jika tanpa flag Secure (hanya HTTPS), HttpOnly (lindungi dari script), atau SameSite (batasi cross-site). Django menanganinya dengan middleware CSRF protection yang otomatis menambahkan token, dukungan set_cookie() untuk flag keamanan seperti secure=True dan httponly=True, serta session framework yang menyimpan data server-side dengan cookie ID terenkripsi, meminimalkan risiko eksposur data sensitif. 

Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step (bukan hanya sekadar mengikuti tutorial).
-> Pertama, saya membuat fungsi registrasi, login, dan logout untuk memungkinkan pengguna mengakses aplikasi sebelumnya sesuai dengan status login/logoutnya. Saya mengerjakan hal tersebut dengan menambahkan import dan fungsi di views.py. Kemudian, saya mengatur file HTML untuk lama regist atau login. Lalu, saya menambahkan fungsi yang saya buat di views.py ke urls.py dengan di import dan menambahkan path url ke dalam urlpatterns untuk akses fungsi.

Kedua, saya menghubungkan model Product dengan user melalui models.py dimana saya mengubah class Product dan migrate models. Lalu, saya mengubah fungsi create_product dan show_main di views.py sesuai tutorial. Saya mengatur bagaimana caranya Django tidak langsung menyimpan objek hasil form ke database sehingga saya memiliki kesempatan untuk memodifikasi objek tersebut terlebih dahulu sebelum disimpan. Kesempatan tersebut tujuannya agar saya dapat mengisi field user dengan nilai request.user, yaitu pengguna yang sedang login. Dengan cara ini, setiap objek yang dibuat akan secara otomatis terhubung dengan pengguna yang membuatnya.

Ketiga, saya menampilkan detail informasi pengguna yang sedang logged in seperti username di main.html dan menerapkan cookies seperti last_login pada halaman utama aplikasi menggunakan datetime dengan mengubah views.py.


TUGAS 3

Jelaskan mengapa kita memerlukan data delivery dalam pengimplementasian sebuah platform? 
-> Dalam pengimplementasian sebuah platform, data delivery diperlukan untuk menjamin informasi yang disampaikan antar komponen sistem berjalan dengan sesuai. Komunikasi client-server dapat terjadi juga melalui data delivery yang memungkinkan pertukaran informasi antara frontend dan backend. Selain itu, data delivery juga penting untuk menjaga keamanan data serta memungkinkan integrasi sistem, yaitu tepatnya komunikasi antar microservices.

Menurutmu, mana yang lebih baik antara XML dan JSON?
-> Mengapa JSON lebih populer dibandingkan XML? Menurut saya, secara umum JSON lebih baik daripada XML karena sintaks yang lebih sederhana dan ukuran file yang lebih ringan sehingga mempercepat pertukaran data. Sementara, XML sintaksnya lebih rumit karena banyak tag yang membuatnya kurang enak saat dibaca. Kelebihan JSON tersebut juga lah yang membuatnya lebih populer dibanding XML. Selain itu, kemudahan penggunaan JSON dan dukungan yang luas di API modern membuat JSON lebih populer dibandingkan XML.

Jelaskan fungsi dari method is_valid() pada form Django dan mengapa kita membutuhkan method tersebut? 
-> is_valid() merupakan method bawaan Django untuk form validation yang berperan dalam memeriksa apakah data yang diinput sesuai dengan aturan validasi yang telah ditentukan, baik validasi bawaan maupun validasi kustom yang kita definisikan sendiri. Jika data valid, method akan mengembalikan true, vice versa. Kita membutuhkan method is_valid() untuk menjamin data yang masuk konsisten, tidak salah format, dan tidak berpotensi menimbulkan bug serta celah keamanan.

Mengapa kita membutuhkan csrf_token saat membuat form di Django? Apa yang dapat terjadi jika kita tidak menambahkan csrf_token pada form Django? Bagaimana hal tersebut dapat dimanfaatkan oleh penyerang? 
-> CSRF token adalah mekanisme keamanan yang penting dalam pengembangan berbasis platform. CSRF token akan menggenerate token unik untuk setiap session dan token disisipkan dalam form sebagai hidden fild kemudian server akan memverifikasi token saat menerima request POST. Tanpa CSRF token, penyerang dapat memanfaatkan celah keamanan untuk melakukan serangan Cross-Site Request Forgery (CSRF), yaitu serangan dimana penyerang mencoba membuat pengguna yang sudah login melakukan aksi tanpa sadar (misalnya mengirim form atau melakukan transaksi) melalui permintaan palsu. Oleh karena itu, CSRF token penting untuk memastikan form submission berasal dari situs yang sah dan melindungi dari request palsu situs lain.

Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step (bukan hanya sekadar mengikuti tutorial).
-> Pertama, saya membuat sebuah ProductForm yang nantinya digunakan sebagai form input saat menambahkan produk baru ke dalam sistem. Form tersebut kemudian dihubungkan dengan template create_product.html agar pengguna bisa mengisi data produk ketika ingin menambahkan produk. Selanjutnya, saya mengedit main.html agar dapat menampilkan daftar semua produk yang tersimpan beserta informasi pentingnya, lalu menambahkan product_detail.html untuk menampilkan detail lengkap dari sebuah produk tertentu. Selain itu, saya menambahkan fungsi pada views.py untuk menangani proses pembuatan produk baru serta fungsi lain untuk menyajikan data produk dalam format JSON maupun XML sehingga lebih fleksibel jika data ingin diakses sebagai API. Demi keamanan, saya menambahkan pengaturan CSRF_TRUSTED_ORIGINS agar form hanya menerima input dari sumber tepercaya dan tidak mudah dieksploitasi penyerang. Terakhir, saya membuat template utama base.html sebagai kerangka dasar agar semua halaman memiliki struktur yang konsisten dan lebih mudah dikelola.

Apakah ada feedback untuk asdos di tutorial 2 yang sudah kalian kerjakan? 
-> Tidak ada, asisten dosen tutorial 2 telah menjalankan perannya dengan sangat baik.

Mengakses keempat URL di poin 2 menggunakan Postman, membuat screenshot dari hasil akses URL pada Postman, dan menambahkannya ke dalam README.md
https://drive.google.com/drive/folders/1K4Bjez69LycL8rXvUteGTiNcE0g_iquj?usp=sharing



TUGAS 2

1. Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step (bukan hanya sekadar mengikuti tutorial).

Membuat sebuah proyek Django baru.
-> siapkan folder proyek dan virtual environment supaya dependensi terisolasi dari sistem, ini mencegah konflik versi library antar proyek dan memudahkan reproducibility. Setelah mengaktifkan venv saya menginstal Django (dan  python-dotenv untuk membaca environment variable) lalu menjalankan django-admin startproject untuk membuat struktur dasar proyek. Sebelum melanjutkan saya menjalankan python manage.py migrate untuk memastikan skema database awal dibuat, dan runserver untuk memverifikasi bahwa proyek bisa dijalankan secara lokal — jika ada error, saya periksa settings.py. Saya juga membuat .gitignore yang memasukkan env/, .env, dan db.sqlite3 agar tidak meng-commit file sensitif lokal.

Membuat aplikasi dengan nama main pada proyek tersebut.
-> Setelah proyek dasar berhasil, saya membuat app main dengan python manage.py startapp main untuk memisahkan modularisasi. Langkah berikutnya adalah mendaftarkan main di INSTALLED_APPS di settings.py sehingga Django mengenali model, view, dan template app ini. Pada tahap ini saya juga menyiapkan struktur folder templates/main/ dan static/main/ karena pemisahan template dan aset mempermudah pengembangan dan testing tampilan. Tujuannya agar setiap fitur (mis. produk) berada dalam satu app yang mudah diuji dan dipindahkan ke proyek lain bila perlu.

Melakukan routing pada proyek agar dapat menjalankan aplikasi main.
-> Saya buat file main/urls.py berisi pemetaan URL lokal aplikasi (mis. path('', views.show_main, name='show_main')) lalu meng-include file itu di level proyek (football_news/urls.py) sehingga root project diarahkan ke app main.  ini menjaga agar routing tingkat aplikasi tetap ringkas dan memudahkan tim untuk menambahkan route baru tanpa mengotori project/urls.py. Setelah include, saya jalankan server lokal dan mengunjungi http://localhost:8000 untuk memastikan view utama tampil. jika tidak, saya cek urutan include dan import error .

Membuat model pada aplikasi main dengan nama Product dan memiliki atribut wajib sebagai berikut.
-> Untuk model produk saya mendesain field berdasarkan kebutuhan fungsional: id bertipe UUIDField sebagai primary key agar unik dan aman saat direplikasi/di-merge; name (CharField) untuk nama, description (TextField) untuk deskripsi panjang; price memakai DecimalField (bukan float) supaya perhitungan uang tetap presisi; stock (PositiveIntegerField) untuk stok; thumbnail (ImageField) bila butuh gambar. Setelah membuat model, saya selalu melakukan makemigrations dan migrate, lalu cek admin Django (daftarkan model di admin.py) untuk memverifikasi data bisa dibuat/diedit lewat UI.

Membuat sebuah fungsi pada views.py untuk dikembalikan ke dalam sebuah template HTML yang menampilkan nama aplikasi serta nama dan kelas kamu.
-> Di views.py saya buat fungsi show_main(request) yang membangun context berisi app_name, name, dan class lalu memanggil render(request, 'main/main.html', context). Alasan menaruh data sederhana ini di context adalah untuk memisahkan logika controller (view) dan tampilan (template) sesuai prinsip MVT—view mempersiapkan data, template hanya menampilkan. Untuk template saya sarankan menggunakan template inheritance (base.html) agar nanti bisa menambah layout konsisten. 

Membuat sebuah routing pada urls.py aplikasi main untuk memetakan fungsi yang telah dibuat pada views.py.
-> Di main/urls.py saya tulis route eksplisit, berikan name pada route (mis. name='show_main') sehingga di template atau test bisa memakai reverse()/url dengan nama route, bukan hardcode URL. Memberi nama route memudahkan refactor URL tanpa mengubah banyak file. Setelah mapping dibuat, saya cek ulang konfigurasi include di level proyek dan jalankan test yang memanggil reverse('show_main') untuk memastikan route sudah benar.

Melakukan deployment ke PWS terhadap aplikasi yang sudah dibuat sehingga nantinya dapat diakses oleh teman-temanmu melalui Internet.
-> Untuk deployment saya ikuti alur pada tutorial: pertama pastikan repository bersih (hapus file sensitif), buat requirements.txt dengan pip freeze, dan pastikan gunicorn ada jika PWS membutuhkan WSGI server. Di settings.py saya ubah supaya membaca SECRET_KEY, DEBUG, dan ALLOWED_HOSTS dari environment variables — ini agar tidak menyimpan rahasia di repo. Selanjutnya push kode ke GitHub dan hubungkan repository ke PWS lewat dashboard SSO UI; di situ saya set environment variables (SECRET_KEY, DEBUG=false, ALLOWED_HOSTS=<host PWS>), dan jalankan prosedur deploy yang disediakan (beberapa PWS menyediakan automatic deploy dari branch main). Setelah deploy, saya cek logs dari panel PWS: jika aplikasi error saya periksa error stack (biasanya terkait SECRET_KEY, missing migrations, atau dependency). Untuk database produksi sebaiknya gunakan Postgres (atau DB yang direkomendasikan PWS) dan atur DATABASE_URL di env; jalankan manage.py migrate pada environment deploy (dri console PWS atau build hook).  pastikan static files di-handle dan media files disimpan di storage yang tersedia. Intinya: deploy = push kode + set env vars + jalankan migrate + verifikasi logs + test akses publik.



2. Buatlah bagan yang berisi request client ke web aplikasi berbasis Django beserta responnya dan jelaskan pada bagan tersebut kaitan antara urls.py, views.py, models.py, dan berkas html.
->  Client (Browser) → URL (urls.py) → View (views.py) → Model (models.py) → Template (HTML) → Response ke Client

urls.py: bertugas memetakan URL yang diminta client ke fungsi tertentu di views.py.

views.py: menjalankan logika bisnis, memproses request, mengambil/mengolah data dari models.py, lalu memilih template untuk ditampilkan.

models.py: berisi representasi data (ORM) yang terhubung ke database. View akan memanggil model ini untuk operasi CRUD.

Template (HTML): menerima data dari view dalam bentuk context, lalu merendernya menjadi halaman web yang siap ditampilkan.

Response: hasil akhir (halaman HTML) dikembalikan ke browser.

3. Jelaskan peran settings.py dalam proyek Django!
Bagaimana cara kerja migrasi database di Django?
-> Peran settings.py berfungsi sebagai pusat konfigurasi proyek django. Di dalamnya terdapat pengaturan database, daftar aplikasi (INSTALLED_APPS), konfigurasi middleware, template, static files, serta variabel lingkungan lainnya. Dengan adanya settings.py, kita bisa mengatur bagaimana seluruh komponen Django beroperasi dalam satu proyek. Cara kerja migrasi database di Django
Proses migrasi dilakukan dalam dua tahap:

makemigrations: membaca perubahan pada models.py dan membuat file migrasi (semacam blueprint skema database).

migrate: menerapkan blueprint tersebut ke database sehingga struktur tabel benar-benar dibuat atau diperbarui.

Alasan keduanya dipisahkan adalah agar developer bisa meninjau dulu perubahan skema sebelum diterapkan. Jika hanya menjalankan makemigrations tanpa migrate, perubahan hanya tercatat di file migrasi tapi tidak dieksekusi ke database

4. Menurut Anda, dari semua framework yang ada, mengapa framework Django dijadikan permulaan pembelajaran pengembangan perangkat lunak?
-> Django dijadikan framework pertama dalam pembelajaran karena memiliki arsitektur MTV (Model–Template–View) yang jelas memisahkan data, logika, dan tampilan sehingga mahasiswa lebih mudah memahami prinsip separation of concern. Selain itu, Django sudah menyediakan banyak fitur bawaan seperti ORM, admin panel, dan autentikasi sehingga pemula dapat langsung membangun aplikasi nyata tanpa harus menyiapkan semuanya dari awal. Ditambah lagi, Django berbasis Python yang relatif mudah dipelajari dan sudah dikenal sebelumnya, serta populer di industri sehingga relevan untuk mahasiswa

5. Apakah ada feedback untuk asisten dosen tutorial 1 yang telah kamu kerjakan sebelumnya?
-> Tutorial 1 sudah cukup membantu memahami alur kerja MTV di Django dan pembuatan tuugas secara keseluruhan.